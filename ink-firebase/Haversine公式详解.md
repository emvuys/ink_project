# Haversine 公式详解

## 什么是 Haversine 公式？

**Haversine 公式**是一个用于计算地球表面两点之间**大圆距离**（最短距离）的数学公式。它特别适用于计算两个经纬度坐标点之间的实际距离。

---

## 为什么需要 Haversine 公式？

### 问题背景

地球是一个**球体**（更准确地说是椭球体），不是平面。因此，我们不能简单地使用欧几里得距离公式（两点间直线距离）来计算两个GPS坐标之间的距离。

### 为什么不能用简单的直线距离？

如果我们有两个GPS坐标点：
- 点A：纽约 (40.7128°N, -74.0060°W)
- 点B：洛杉矶 (34.0522°N, -118.2437°W)

如果使用简单的直线距离公式：
```
距离 = √[(lat₂ - lat₁)² + (lng₂ - lng₁)²]
```

这会产生**错误的结果**，因为：
1. 纬度1度 ≠ 经度1度的实际距离
2. 地球是球面，不是平面
3. 经度之间的距离在不同纬度下是不同的

### Haversine 公式的优势

- ✅ 考虑了地球的曲率
- ✅ 计算的是**大圆距离**（球面上两点间最短路径）
- ✅ 精度高，适合短距离计算（< 100公里误差 < 0.5%）
- ✅ 计算效率高，适合实时应用

---

## 数学公式

### 基本公式

给定两个点的经纬度：
- 点1：纬度 `φ₁`，经度 `λ₁`
- 点2：纬度 `φ₂`，经度 `λ₂`

**Haversine 公式**：

```
a = sin²(Δφ/2) + cos(φ₁) × cos(φ₂) × sin²(Δλ/2)
c = 2 × atan2(√a, √(1-a))
d = R × c
```

其中：
- `Δφ = φ₂ - φ₁`（纬度差）
- `Δλ = λ₂ - λ₁`（经度差）
- `R` = 地球半径（6,371,000 米）
- `d` = 两点间距离（米）

### 公式组成部分

#### 1. Haversine 函数

**Haversine** 是 "half-versed sine" 的缩写，定义为：

```
hav(θ) = sin²(θ/2) = (1 - cos(θ)) / 2
```

#### 2. 角度转弧度

经纬度通常以**度**为单位，但三角函数需要**弧度**：

```
弧度 = 度数 × (π / 180)
```

#### 3. 地球半径

- **平均半径**：R = 6,371,000 米 = 6,371 公里
- **赤道半径**：6,378,137 米（稍大）
- **极半径**：6,356,752 米（稍小）

对于大多数应用，使用平均半径即可。

---

## 代码实现

### JavaScript 实现

```javascript
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3; // 地球半径（米）：6,371,000
  
  // 将角度转换为弧度
  const φ1 = lat1 * Math.PI / 180;  // 纬度1（弧度）
  const φ2 = lat2 * Math.PI / 180;  // 纬度2（弧度）
  const Δφ = (lat2 - lat1) * Math.PI / 180;  // 纬度差（弧度）
  const Δλ = (lon2 - lon1) * Math.PI / 180;  // 经度差（弧度）

  // Haversine 公式
  const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
  
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  // 返回距离（米）
  return R * c;
}
```

### 步骤分解

#### 步骤1：角度转弧度
```javascript
const φ1 = lat1 * Math.PI / 180;  // 例如：40.7128° → 0.7098 弧度
const φ2 = lat2 * Math.PI / 180;
const Δφ = (lat2 - lat1) * Math.PI / 180;  // 纬度差
const Δλ = (lon2 - lon1) * Math.PI / 180;  // 经度差
```

#### 步骤2：计算 Haversine 值
```javascript
const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +      // sin²(Δφ/2)
          Math.cos(φ1) * Math.cos(φ2) *               // cos(φ₁) × cos(φ₂)
          Math.sin(Δλ / 2) * Math.sin(Δλ / 2);        // × sin²(Δλ/2)
```

#### 步骤3：计算中心角
```javascript
const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
```

`atan2` 函数用于计算角度，比 `atan` 更准确，因为它考虑了象限。

#### 步骤4：计算距离
```javascript
return R * c;  // 距离 = 半径 × 中心角（弧度）
```

---

## 实际示例

### 示例1：短距离（配送验证场景）

**点A（配送地址）**：
- 纬度：40.7128°N
- 经度：-74.0060°W

**点B（交付位置）**：
- 纬度：40.7129°N
- 经度：-74.0061°W

**计算过程**：
```
Δφ = 40.7129 - 40.7128 = 0.0001° = 0.000001745 弧度
Δλ = -74.0061 - (-74.0060) = -0.0001° = -0.000001745 弧度

a = sin²(0.000001745/2) + cos(0.7098) × cos(0.7098) × sin²(-0.000001745/2)
a ≈ 7.6 × 10⁻¹²

c = 2 × atan2(√a, √(1-a)) ≈ 1.75 × 10⁻⁶ 弧度

距离 = 6,371,000 × 1.75 × 10⁻⁶ ≈ 11.1 米
```

**结果**：约 **11 米** ✅

### 示例2：中等距离

**点A**：纽约 (40.7128°N, -74.0060°W)  
**点B**：费城 (39.9526°N, -75.1652°W)

**结果**：约 **130 公里**

### 示例3：长距离

**点A**：纽约 (40.7128°N, -74.0060°W)  
**点B**：洛杉矶 (34.0522°N, -118.2437°W)

**结果**：约 **3,944 公里**

---

## 精度和限制

### 精度

- **短距离**（< 100公里）：误差通常 < 0.5%
- **中等距离**（100-1000公里）：误差 < 1%
- **长距离**（> 1000公里）：误差可能达到 1-3%

### 为什么有误差？

1. **地球不是完美球体**：地球是椭球体，赤道半径比极半径大约 21 公里
2. **海拔高度**：公式假设所有点都在海平面上
3. **地形**：实际路径可能受地形影响

### 更精确的替代方案

对于需要更高精度的应用，可以使用：

1. **Vincenty 公式**：考虑地球椭球体，精度更高，但计算更复杂
2. **大圆距离库**：使用专业的地理计算库

但对于**配送验证**场景（通常距离 < 1公里），Haversine 公式的精度完全足够。

---

## 在项目中的应用

### 使用场景

在 INK NFS 项目中，Haversine 公式用于：

1. **验证配送位置**：计算客户点击NFC标签时的位置与配送地址的距离
2. **判定规则**：
   - ≤ 100米：自动通过
   - 100-300米：需要手机验证
   - > 300米：标记为异常

### 代码位置

- **实现文件**：`src/utils/gps.js`
- **使用位置**：`src/routes/verify.js`（第45-50行）

### 性能考虑

- **计算速度**：非常快（< 1毫秒）
- **适合实时计算**：可以处理大量并发请求
- **无需外部API**：纯数学计算，不依赖网络

---

## 公式推导（简化版）

### 球面三角学基础

在单位球面上，两点间的大圆距离可以通过**球面余弦定理**计算：

```
cos(d) = sin(φ₁) × sin(φ₂) + cos(φ₁) × cos(φ₂) × cos(Δλ)
```

但直接使用这个公式在计算上可能不稳定（当距离很小时）。

### Haversine 公式的优势

Haversine 公式通过使用 `hav(θ) = sin²(θ/2)` 来避免数值不稳定问题：

```
hav(d) = hav(Δφ) + cos(φ₁) × cos(φ₂) × hav(Δλ)
```

然后通过反函数得到距离：

```
d = 2 × R × arcsin(√hav(d))
```

实际实现中使用 `atan2` 而不是 `arcsin`，因为：
- `atan2` 更稳定
- 可以处理所有角度范围

---

## 可视化理解

### 大圆路径

```
        地球表面
           |
    A -------- B  ← 大圆路径（最短距离）
     \       /
      \     /
       \   /
        \ /
         O  ← 地心
```

两点间的大圆路径是**球面上最短的路径**，类似于飞机飞行的航线。

### 中心角

```
        A
        |
        |  ← 中心角 c
        |
        O  ← 地心
        |
        |
        B
```

距离 = 半径 × 中心角（弧度）

---

## 总结

### 关键要点

1. **Haversine 公式**用于计算地球表面两点间的大圆距离
2. **适用场景**：GPS坐标距离计算，特别是短到中等距离
3. **精度**：对于配送验证场景（< 1公里）完全足够
4. **优势**：计算快速、实现简单、无需外部依赖
5. **在项目中的作用**：判断配送位置是否在正确地址附近

### 公式记忆

```
a = sin²(Δφ/2) + cos(φ₁) × cos(φ₂) × sin²(Δλ/2)
c = 2 × atan2(√a, √(1-a))
距离 = R × c
```

记住：**Haversine = Half-Versed Sine = sin²(θ/2)**

---

## 参考资料

- [Wikipedia: Haversine formula](https://en.wikipedia.org/wiki/Haversine_formula)
- [Movable Type Scripts: Calculate distance](https://www.movable-type.co.uk/scripts/latlong.html)
- 球面三角学基础

